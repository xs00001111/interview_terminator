<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview Terminator</title>
    <link rel="stylesheet" href="styles-plan-modal.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="google-auth-styles.css">
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <!-- MathJax for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
        };
    </script>


 
            
</head>
<body>
    <!-- Compact draggable bar -->
    <div class="compact-bar" id="compactBar">

        
        <!-- Status indicator removed - button states provide sufficient feedback -->
        
        <div class="action-buttons">
            <svg class="app-logo-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <!-- Dark blue background with rounded corners -->
                <rect x="0" y="0" width="24" height="24" fill="#2b4b6f" rx="5" ry="5" />
                
                <!-- Hexagon element (purple) -->
                <polygon points="12,4 16,7 16,13 12,16 8,13 8,7" fill="#9c5ec6" />
                
                <!-- Small triangle (teal) -->
                <polygon points="12,18 15,21 9,21" fill="#3ecfb2" />
                
                <!-- Curved line (light yellow) -->
                <path d="M6,10 Q12,18 18,10" stroke="#f7e379" stroke-width="2" fill="none" />
            </svg>
            <button class="action-btn listen-now-btn" id="recordBtn" title="Start/Stop Recording">
                  <svg viewBox="0 0 24 24" width="17" height="17">
                      <g class="soundwave-bars">
                          <rect class="bar" x="9" y="8" width="2" height="8" rx="1"/>
                          <rect class="bar" x="12" y="6" width="2" height="12" rx="1"/>
                          <rect class="bar" x="15" y="8" width="2" height="8" rx="1"/>
                      </g>
                  </svg>
                  <div class="loading-spinner"></div>
                  <span class="listen-text">Start Listen <span class="hotkey-hint">(⌘L)</span></span>
              </button>
            
            <button class="action-btn ai-btn" id="aiBtn" title="AI Answer (⌘↵)">
                <span>Answer <span class="hotkey-hint">(⌘↵)</span></span>
            </button>
            
            <button class="action-btn screenshot-btn" id="screenshotBtn" title="Screenshot" data-tooltip="Screenshot">
                <svg viewBox="0 0 24 24" width="17" height="17" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
                    <circle cx="12" cy="13" r="3"/>
                </svg>
                <span class="hotkey-hint">(⌘⇧↵)</span>
            </button>
            

        </div>
        
        <button class="action-btn expand-btn" id="expandBtn" title="Menu">
            <svg viewBox="0 0 24 24" fill="white">
                <path d="M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z"/>
            </svg>
        </button>

    </div>
    <div id="statusBar" class="status-bar"></div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <div class="toast-content">
            <span id="toast-message"></span>
            <button id="toast-action" class="toast-action-btn">Open Settings</button>
        </div>
        <button id="toast-close" class="toast-close">&times;</button>
    </div>

    <!-- Main container that holds pop-ups -->
    <div id="root">
        <!-- Unified Panel Stack -->
        <div id="popupStack">
            <!-- AI Suggestion Card -->
            <div class="ai-card" id="aiCard">
                <div class="card-header">
                    <!-- ① red close button, fixed to the left -->
                    <button class="card-close-btn" id="aiCardClose" title="Close"></button>

                    <!-- centred title -->
                    <div class="card-title">AI Suggestion</div>

                    <!-- ② “T” toggle button, fixed to the right -->
                    <button class="card-toggle-btn" id="transcriptToggleBtn" title="Transcript">T</button>
                </div>
                <div class="card-content" id="aiCardContent">
                    <div class="placeholder-message">
                        <p style="color: var(--text-secondary-dark); text-align: center; padding: 40px 20px; font-style: italic;">AI suggestions will appear here when you click the Answer button</p>
                    </div>
                    <div class="ai-card-copy-container">
                        <button class="card-copy-btn" id="aiCardCopy" title="Copy AI text (⌘⇧C)">
                            Copy
                        </button>
                    </div>
                </div>
            </div>

            <!-- Transcript Card -->
            <div class="transcript-card" id="transcriptCard">
                <div class="card-header">
                    <div class="card-title">

                        Transcript
                    </div>
                </div>
                <div class="card-content" id="transcriptCardContent">
                    <div class="placeholder-message">
                        <p style="color: var(--text-secondary-dark); text-align: center; padding: 40px 20px; font-style: italic;">Conversation transcript will appear here as you record interviews</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Authentication Container -->
    <div class="auth-container" id="authContainer">
        <div class="auth-header">
            <h3>Sign In</h3>
            <button class="close-auth" id="closeAuth">&times;</button>
        </div>
        <form class="auth-form" id="authForm">
            <div class="auth-status" id="authStatus"></div>
            <button type="button" class="google-login-button" id="googleLoginBtn">
                <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 8px;">
                    <path fill="#4285f4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34a853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#fbbc05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#ea4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Continue with Google
            </button>
            <div class="auth-divider">
                <span>or</span>
            </div>
            <input type="email" id="emailInput" placeholder="Email" required>
            <input type="password" id="passwordInput" placeholder="Password" required>
            <button type="submit" class="login-button">Sign In</button>
        </form>
    </div>






    <!-- Expanded Menu Panel -->
    <div class="expanded-menu" id="expandedMenu">
        <div class="menu-header">
            <button class="menu-control-btn" id="closeExpandedMenu" title="close">
                    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 3L9 9M9 3L3 9"/>
                    </svg>
            </button>
            <div class="menu-title">Menu</div>
        </div>
        
        <!-- User Section -->
        <div class="menu-section">
            <div class="user-info" id="userInfo" style="display: none;">
                <div class="user-avatar">JD</div>
                <div class="user-details">
                    <div class="user-name">Jane Doe</div>
                    <div class="user-status">Premium User</div>
                </div>
            </div>
            
            <!-- NEW: lives *after* .user-info so it spans the whole width -->
            <div class="interviews-left-row menu-item" id="interviewsLeftItem" style="display: none;">
                Interviews Left: <span id="interviewsLeftCount">--</span>
            </div>
            
            <div class="login-prompt" id="loginPrompt">
                <div style="margin-bottom: 8px;">Sign in to start using the app</div>
                <button class="login-btn" id="loginBtn">Sign In</button>
            </div>
        </div>
        

        
        <!-- General Section -->
        <div class="menu-section">
            <div class="menu-section-title">General</div>
            <div class="menu-item" id="logoutItem">
                <div class="menu-item-content">
                    <svg class="menu-item-icon" viewBox="0 0 24 24">
                        <path d="M16,17V14H9V10H16V7L21,12L16,17M14,2A2,2 0 0,1 16,4V6H14V4H5V20H14V18H16V20A2,2 0 0,1 14,22H5A2,2 0 0,1 3,20V4A2,2 0 0,1 5,2H14Z" fill="currentColor"/>
                    </svg>
                    <span class="menu-item-text">Sign Out</span>
                </div>
            </div>
        </div>
        
        <!-- Help Section -->
        <div class="menu-section">
            <div class="menu-section-title">Help & Support</div>
            <div class="menu-item" id="helpItem">
                <div class="menu-item-content">
                    <svg class="menu-item-icon" viewBox="0 0 24 24">
                        <path d="M11,18H13V16H11V18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,6A4,4 0 0,0 8,10H10A2,2 0 0,1 12,8A2,2 0 0,1 14,10C14,12 11,11.75 11,15H13C13,12.75 16,12.5 16,10A4,4 0 0,0 12,6Z" fill="currentColor"/>
                    </svg>
                    <span class="menu-item-text">Help Center</span>
                </div>
            </div>

            <div class="menu-item" id="minimizeItem">
                <div class="menu-item-content">
                    <svg class="menu-item-icon" viewBox="0 0 24 24">
                        <path d="M20,14H4V10H20" fill="currentColor"/>
                    </svg>
                    <span class="menu-item-text">Minimize</span>
                </div>
            </div>
            <div class="menu-item" id="quitItem">
                <div class="menu-item-content">
                    <svg class="menu-item-icon" viewBox="0 0 24 24">
                        <path d="M19,3H5C3.89,3 3,3.89 3,5V9H5V5H19V19H5V15H3V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M10.08,15.58L11.5,17L16.5,12L11.5,7L10.08,8.41L12.67,11H3V13H12.67L10.08,15.58Z" fill="currentColor"/>
                    </svg>
                    <span class="menu-item-text">Quit</span>
                </div>
            </div>

        </div>
    </div>



    <script>
        // Constants from constants.js - updated for dynamic sizing
        const BAR_HEIGHT = 60;
        const WINDOW_WIDTH = 600;
        const MENU_HEIGHT = 600;
        const MIN_PANEL_HEIGHT = 200;
        const MAX_PANEL_HEIGHT = 500;
        const DUAL_PANEL_WIDTH = 800;
        const CONTENT_PADDING = 24;
        const HEADER_HEIGHT = 44;

        // Authentication services will be available through window.electron.auth

        // Dragging functionality
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        const compactBar = document.getElementById('compactBar');

        const expandedMenu = document.getElementById('expandedMenu');
        // Status indicator removed
        const recordBtn = document.getElementById('recordBtn');
        const aiBtn = document.getElementById('aiBtn');
        const expandBtn = document.getElementById('expandBtn');

        const closeExpandedMenu = document.getElementById('closeExpandedMenu');




        
        // PERMISSION ERROR HANDLING
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toast-message');
        const toastAction = document.getElementById('toast-action');
        const toastClose = document.getElementById('toast-close');



        if(toastClose) {
            toastClose.addEventListener('click', () => {
                console.log('Toast close button clicked!');
                hidePermissionToast();
                console.log('Toast should now be hidden');
            });
        } else {
            console.error('Toast close button not found!');
        }

        toastAction.addEventListener('click', (e) => {
            console.log('Toast action button clicked!');
            const url = toastAction.dataset.url;
            console.log('URL from dataset:', url);
            if (!url) {
                console.log('No URL found in dataset');
                return;
            }

            // Prefer Electron's helper if preload exposed it
            if (window.electron?.openExternal) {
                console.log('Using electron.openExternal');
                window.electron.openExternal(url);
            } else {
                console.log('Using window.open fallback');
                window.open(url, '_blank', 'noopener,noreferrer');
            }
        });

        // New unified panel elements
        const popupStack = document.getElementById('popupStack');
        const aiCard = document.getElementById('aiCard');
        const transcriptCard = document.getElementById('transcriptCard');
        const aiCardClose = document.getElementById('aiCardClose');
        // transcriptCardClose removed - no longer needed
        const aiCardCopy = document.getElementById('aiCardCopy');

        // File Upload Handling
        function setupFileUpload(inputId, fileNameId, clearBtnId) {
            const fileInput = document.getElementById(inputId);
            const fileNameDisplay = document.getElementById(fileNameId);
            const clearButton = document.getElementById(clearBtnId);

            if (fileInput && fileNameDisplay && clearButton) {
                fileInput.addEventListener('change', function() {
                    if (this.files && this.files.length > 0) {
                        fileNameDisplay.textContent = this.files[0].name;
                        clearButton.style.visibility = 'visible';
                    } else {
                        fileNameDisplay.textContent = 'No file chosen';
                        clearButton.style.visibility = 'hidden';
                    }
                });
            }
        }

        function clearFile(inputId, fileNameId, clearBtnId) {
            const fileInput = document.getElementById(inputId);
            const fileNameDisplay = document.getElementById(fileNameId);
            const clearButton = document.getElementById(clearBtnId);

            if (fileInput) fileInput.value = ''; // Clear the file input
            if (fileNameDisplay) fileNameDisplay.textContent = 'No file chosen';
            if (clearButton) clearButton.style.visibility = 'hidden';
        }

        setupFileUpload('resumeUpload', 'resumeFileName', 'clearResumeBtn');
        setupFileUpload('jobDescUpload', 'jobDescFileName', 'clearJobDescBtn');

        // Initialize file upload display
        clearFile('resumeUpload', 'resumeFileName', 'clearResumeBtn');
        clearFile('jobDescUpload', 'jobDescFileName', 'clearJobDescBtn');

        
        // Menu elements
        const userInfo = document.getElementById('userInfo');
        const loginPrompt = document.getElementById('loginPrompt');
        const loginBtn = document.getElementById('loginBtn');
        const logoutItem = document.getElementById('logoutItem');
        
        // Track login state
        let isLoggedIn = false;
        let currentUser = null;
        let userPlan = null;

        // Drag functionality
        compactBar.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (e.target.closest('.action-btn')) return; // Don't drag when clicking buttons
            
            initialX = e.clientX - xOffset;
            initialY = e.clientY - yOffset;

            if (e.target === compactBar || e.target.closest('.brand')) {
                isDragging = true;
                compactBar.style.cursor = 'grabbing';
            }
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;

                xOffset = currentX;
                yOffset = currentY;

                compactBar.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        }

        function dragEnd() {
            initialX = currentX;
            initialY = currentY;
            isDragging = false;
            compactBar.style.cursor = 'move';
        }

        // Hotkey listener
        // Set up global hotkey listeners (moved from keydown event to main process)
        window.electron.onTriggerRecordButton(() => {
            recordBtn.click();
        });
        
        window.electron.onTriggerAiButton(() => {
            aiBtn.click();
        });
        
        window.electron.onTriggerTranscriptToggle(() => {
            toggleTranscriptCard();
        });
        
        window.electron.onTriggerCopyAiText(() => {
            copyAIText();
        });

        // Answer interaction functions
        function elaborateAnswer(button) {
            const answerText = button.closest('.answer-card').querySelector('.answer-text').textContent;
            
            // Visual feedback
            button.style.background = 'var(--secondary-hover)';
            button.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24">
                    <path d="M12,2A2,2 0 0,1 14,4V20A2,2 0 0,1 12,22A2,2 0 0,1 10,20V4A2,2 0 0,1 12,2Z" fill="currentColor"/>
                </svg>
                Elaborating...
            `;
            
            // Send elaborate request to backend
            window.electron.elaborate(answerText);
            
            console.log('Elaborating:', answerText);
        }
        
        window.electron.onElaboration((data) => {
            console.log('Received elaboration:', data);

            // Find the elaborate button and reset it
            const elaborateButtons = document.querySelectorAll('.elaborate-btn');
            elaborateButtons.forEach(button => {
                if (button.innerHTML.includes('Elaborating...')) {
                    button.disabled = false;
                    button.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                        Elaborate
                    `;
                }
            });

            // Display the elaboration in the AI popup
            if (data && data.elaboration) {
                const aiCardContent = document.getElementById('aiCardContent');
                if (aiCardContent) {
                    // Create elaboration answer card
                    const elaborationCard = document.createElement('div');
                    elaborationCard.className = 'answer-card elaboration-card';
                    elaborationCard.innerHTML = `
                        <div class="answer-header">
                            <div class="answer-title">Elaboration</div>
                        </div>
                        <div class="answer-text">${data.elaboration}</div>
                        <div class="answer-actions">
                            <button class="copy-btn" onclick="copyAnswer(this)">
                                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z" fill="currentColor"/></svg>
                                Copy
                            </button>
                        </div>
                    `;
                    
                    // Append the elaboration card to the AI popup content
                    aiCardContent.appendChild(elaborationCard);
                    
                    // Ensure the AI popup is visible
                    const aiCard = document.getElementById('aiCard');
                    if (aiCard && !aiCard.classList.contains('show')) {
                        toggleAICard();
                    }
                }
            }
        });

        function showElaboration(answerId) {
            const elaborations = {
                1: "Let me elaborate on system design: First, for scalability, I'd implement horizontal scaling using load balancers like NGINX or AWS ALB to distribute traffic across multiple server instances. For the database layer, I'd use sharding to partition data across multiple databases, ensuring each shard handles a specific range of data. Additionally, I'd implement caching strategies using Redis or Memcached to reduce database load and improve response times.",
                2: "Here's my detailed problem-solving approach: I start by gathering all requirements and constraints, then I break the problem into smaller, manageable components. For example, when I worked on optimizing a slow API, I first identified bottlenecks through profiling, then systematically addressed each issue - database query optimization, caching implementation, and code refactoring. I always document my thought process and test each solution incrementally."
            };
            
        }

        function copyAnswer(button) {
            const answerText = button.closest('.answer-card').querySelector('.answer-text').textContent;
            
            // Copy to clipboard
            navigator.clipboard.writeText(answerText).then(() => {
                // Visual feedback
                const originalContent = button.innerHTML;
                button.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24">
                        <path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" fill="currentColor"/>
                    </svg>
                    Copied!
                `;
                button.style.background = 'var(--secondary-hover-transparent)'; /* Assuming this is for a subtle success indication */
                button.style.color = 'var(--secondary)';
                
                setTimeout(() => {
                    button.innerHTML = originalContent;
                    /* Assuming default button styles are handled by CSS classes, so direct style removal or reset might be better here if applicable */
                    /* For now, let's use a generic light background and text color if no specific variable fits */
                    button.style.background = 'rgba(255, 255, 255, 0.1)'; 
                    button.style.color = 'var(--primary-foreground)'; /* Or a more general text color variable if available */
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        // Button functionality
        let isRecording = false;
        let isProcessing = false;

        recordBtn.addEventListener('click', async () => {
            if (!isLoggedIn) {
                loginBtn.click();
                return;
            }

            if (!isRecording) {
                // Check microphone permissions before starting recording
                console.log('[RENDERER] Starting recording - checking microphone access...');
                const micResult = await window.electron.preloadMicCheck();
                if (!micResult.ok && !micResult.skipped) {
                    console.error('[RENDERER] Cannot start recording - microphone access denied:', micResult);
                    return;
                }
                
                // Start recording - show loading state first
                window.electron.startRecording();
                isRecording = true;
                recordBtn.classList.add('loading');
                
                // Disable screenshot button while recording
                screenshotBtn.disabled = true;
                screenshotBtn.style.opacity = '0.5';
                screenshotBtn.style.cursor = 'not-allowed';
                
                // Update button text
                const listenText = recordBtn.querySelector('.listen-text');
                const hotkeyHint = recordBtn.querySelector('.hotkey-hint').outerHTML;
                listenText.innerHTML = `Stop Listen ${hotkeyHint}`;
            } else {
                // Stop recording
                window.electron.stopRecording();
                isRecording = false;
                recordBtn.classList.remove('active', 'loading');
                
                // Re-enable screenshot button when recording stops
                screenshotBtn.disabled = false;
                screenshotBtn.style.opacity = '1';
                screenshotBtn.style.cursor = 'pointer';
                
                // Update button text
                const listenText = recordBtn.querySelector('.listen-text');
                const hotkeyHint = recordBtn.querySelector('.hotkey-hint').outerHTML;
                listenText.innerHTML = `Start Listen ${hotkeyHint}`;
            }
        });

        aiBtn.addEventListener('click', () => {
            // Close expanded menu if open
            const wasExpandedVisible = expandedMenu.classList.contains('show');
            expandedMenu.classList.remove('show');
            expandBtn.classList.remove('active');
            
            // Update popup manager for expanded menu close
            if (wasExpandedVisible && window.PopupManager) {
                window.PopupManager.onPopupHide();
            }
            
            const transcriptMessages = document.querySelectorAll('.transcript-message .message-text');

            // Get the latest transcript text for AI suggestion
            let transcriptText = '';
            if (transcriptMessages && transcriptMessages.length > 0) {
                // Get the last few messages for context (up to 3 messages)
                // Ensure transcriptMessages is iterable before using Array.from
                const recentMessages = transcriptMessages.length > 0 ? 
                    Array.from(transcriptMessages).slice(-3) : [];
                transcriptText = recentMessages.map(msg => msg.textContent || '').join(' ');
            }
            
            // If no transcript available, use a default prompt
            if (!transcriptText.trim()) {
                transcriptText = 'Please provide interview suggestions and tips.';
            }
            
            // Check if recording is active and there's a transcript
            if (!isRecording || transcriptMessages.length === 0) {
                // Display an error message in the unified AI card
                const aiCardContent = document.getElementById('aiCardContent');
                if (aiCardContent) {
                    aiCardContent.innerHTML = `<div class="answer-card"><div class="answer-text" style="color: var(--error-red);">Error: Please start recording and ensure there is a transcript before requesting AI suggestions.</div></div>`;
                }
                toggleAICard(); // Show unified AI card with error
                return; // Stop further execution
            }

            // Send get-suggestion request
            console.log('[UI] Requesting AI suggestion for text:', transcriptText);
            window.electron.getSuggestion(transcriptText);
            
            // Clear previous content and show loading in unified AI card
            const aiCardContent = document.getElementById('aiCardContent');
            if (aiCardContent) {
                aiCardContent.innerHTML = '<div class="answer-card"><div class="answer-text">Getting AI suggestion...</div></div>'; 
            }
            
            // Show the unified AI card
            if (!aiCard.classList.contains('show')) {
                toggleAICard();
            }
        });

        // Screenshot button functionality
        const screenshotBtn = document.getElementById('screenshotBtn');
        screenshotBtn.addEventListener('click', () => {
            // Don't allow screenshot when button is disabled (during recording)
            if (screenshotBtn.disabled) {
                return;
            }
            
            // Close expanded menu if open
            const wasExpandedVisible = expandedMenu.classList.contains('show');
            expandedMenu.classList.remove('show');
            expandBtn.classList.remove('active');
            
            // Update popup manager for expanded menu close
            if (wasExpandedVisible && window.PopupManager) {
                window.PopupManager.onPopupHide();
            }
            
            // Trigger screenshot capture
            window.electron.takeScreenshot();
        });

        
        // Expand menu functionality
        expandBtn.addEventListener('click', () => {
            // Close AI popup and preferences panel if open

            
            const wasVisible = expandedMenu.classList.contains('show');
            expandedMenu.classList.toggle('show');
            expandBtn.classList.toggle('active', expandedMenu.classList.contains('show'));

            const stack = document.getElementById('popupStack');
            if (expandedMenu.classList.contains('show')) {
                stack.classList.add('blurred');
            } else {
                stack.classList.remove('blurred');
            }
            
            // Update popup manager
            if (window.PopupManager) {
                if (!wasVisible && expandedMenu.classList.contains('show')) {
                    window.PopupManager.onPopupShow();
                } else if (wasVisible && !expandedMenu.classList.contains('show')) {
                    window.PopupManager.onPopupHide();
                }
            }
            
            // Update window size based on new state
            updateWindowSize();
        });
        
        closeExpandedMenu.addEventListener('click', () => {
            expandedMenu.classList.remove('show');
            expandBtn.classList.remove('active');
            
            // Update popup manager
            if (window.PopupManager) {
                window.PopupManager.onPopupHide();
            }
            
            // Update window size based on new state
            updateWindowSize();
        });
        
        // New unified panel event listeners
        if (aiCardClose) {
            aiCardClose.addEventListener('click', () => {
                // Close entire panel (both AI and transcript cards)
                aiCard.classList.remove('show');
                transcriptCard.classList.remove('show');
                if (aiBtn) aiBtn.classList.remove('active');
                updateUnifiedPanels();
                
                // Update popup manager since all cards are now hidden
                if (window.PopupManager) {
                    window.PopupManager.onPopupHide();
                }
            });
        }
        
        // Transcript toggle button event listener
        const transcriptToggleBtn = document.getElementById('transcriptToggleBtn');
        if (transcriptToggleBtn) {
            transcriptToggleBtn.addEventListener('click', () => {
                toggleTranscriptCard();
            });
        }
        
        if (aiCardCopy) {
            aiCardCopy.addEventListener('click', copyAIText);
        }
        
        // AI button event listener is already defined above with proper logic



        // Helper functions to manage window size and panel positions
        function updateWindowSize() {
            const menuVisible = expandedMenu.classList.contains('show');
            const unifiedPanelVisible = popupStack && popupStack.classList.contains('show');
            const aiVisible = aiCard && aiCard.classList.contains('show');
            const transcriptVisible = transcriptCard && transcriptCard.classList.contains('show');
            const toastVisible = toast && toast.classList.contains('show');
            
            let width = WINDOW_WIDTH;
            let height = BAR_HEIGHT;
            
            if (menuVisible) {
                // Menu has fixed height
                height = MENU_HEIGHT;
                width = WINDOW_WIDTH;
            } else if (unifiedPanelVisible) {
                // Calculate optimal size based on actual content
                const optimalSize = calculateOptimalPanelSize(aiVisible, transcriptVisible);
                width = optimalSize.width;
                height = optimalSize.height;
            } else if (toastVisible) {
                // Toast is visible, ensure window is tall enough
                height = BAR_HEIGHT + 100; // Toast height + padding + margin + positioning
            }
            
            window.electron.resizeWindow(width, height);
        }
        
        function calculateOptimalPanelSize(aiVisible, transcriptVisible) {
            const compactBarHeight = 60; // Height of the command bar
            const headerHeight = 44; // Height of card headers
            const padding = 24; // Padding around popup stack
            const minContentHeight = 120; // Minimum content area height
            const maxContentHeight = 400; // Maximum content area height to prevent oversized windows
            
            let totalWidth = WINDOW_WIDTH;
            let totalHeight = compactBarHeight + padding;
            
            if (aiVisible && transcriptVisible) {
                // Both panels visible - use wider layout
                totalWidth = Math.min(800, Math.max(650, WINDOW_WIDTH));
                
                // Calculate content height based on actual content
                let maxContentHeightNeeded = minContentHeight;
                
                if (aiCard && aiCard.querySelector('.card-content')) {
                    const aiContent = aiCard.querySelector('.card-content');
                    const aiContentHeight = Math.min(maxContentHeight, Math.max(minContentHeight, aiContent.scrollHeight));
                    maxContentHeightNeeded = Math.max(maxContentHeightNeeded, aiContentHeight);
                }
                
                if (transcriptCard && transcriptCard.querySelector('.card-content')) {
                    const transcriptContent = transcriptCard.querySelector('.card-content');
                    const transcriptContentHeight = Math.min(maxContentHeight, Math.max(minContentHeight, transcriptContent.scrollHeight));
                    maxContentHeightNeeded = Math.max(maxContentHeightNeeded, transcriptContentHeight);
                }
                
                totalHeight += headerHeight + maxContentHeightNeeded;
                
            } else if (aiVisible || transcriptVisible) {
                // Single panel visible - use compact width
                totalWidth = WINDOW_WIDTH;
                
                const activeCard = aiVisible ? aiCard : transcriptCard;
                if (activeCard && activeCard.querySelector('.card-content')) {
                    const content = activeCard.querySelector('.card-content');
                    const contentHeight = Math.min(maxContentHeight, Math.max(minContentHeight, content.scrollHeight));
                    totalHeight += headerHeight + contentHeight;
                } else {
                    totalHeight += headerHeight + minContentHeight;
                }
            }
            
            return {
                width: totalWidth,
                height: totalHeight
            };
        }



        // New unified panel management functions
        function updateUnifiedPanels() {
            const aiVisible = aiCard && aiCard.classList.contains('show');
            const transcriptVisible = transcriptCard && transcriptCard.classList.contains('show');
            
            if (aiVisible || transcriptVisible) {
                popupStack.classList.add('show');
                
                // Adjust widths based on visibility
                if (aiVisible && transcriptVisible) {
                    aiCard.style.flex = '0 0 60%';
                    transcriptCard.style.flex = '0 0 40%';
                } else if (aiVisible) {
                    aiCard.style.flex = '0 0 100%';
                } else if (transcriptVisible) {
                    transcriptCard.style.flex = '0 0 100%';
                }
                
                // Delay window resize to allow content to render
                setTimeout(() => {
                    updateWindowSize();
                }, 50);
            } else {
                popupStack.classList.remove('show');
                updateWindowSize();
            }
        }
        
        // Debounced resize function for content changes
        let resizeTimeout;
        function debouncedWindowResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateWindowSize();
            }, 100);
        }
        
        // Content change observer for dynamic resizing
        function setupContentObserver() {
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(debouncedWindowResize);
                
                if (aiCard && aiCard.querySelector('.card-content')) {
                    resizeObserver.observe(aiCard.querySelector('.card-content'));
                }
                
                if (transcriptCard && transcriptCard.querySelector('.card-content')) {
                    resizeObserver.observe(transcriptCard.querySelector('.card-content'));
                }
            }
        }
        
        function toggleAICard() {
            if (!aiCard) return;
            
            const wasVisible = aiCard.classList.contains('show');
            aiCard.classList.toggle('show');
            
            // Update AI button state
            if (aiBtn) {
                aiBtn.classList.toggle('active', !wasVisible);
            }
            
            updateUnifiedPanels();
            
            // Update popup manager
            if (window.PopupManager) {
                if (!wasVisible) {
                    window.PopupManager.onPopupShow();
                } else {
                    const transcriptVisible = transcriptCard && transcriptCard.classList.contains('show');
                    if (!transcriptVisible) {
                        window.PopupManager.onPopupHide();
                    }
                }
            }
        }
        
        function toggleTranscriptCard() {
            if (!transcriptCard) return;
            
            const wasVisible = transcriptCard.classList.contains('show');
            transcriptCard.classList.toggle('show');
            
            updateUnifiedPanels();
            
            // Update popup manager
            if (window.PopupManager) {
                if (!wasVisible) {
                    window.PopupManager.onPopupShow();
                } else {
                    const aiVisible = aiCard && aiCard.classList.contains('show');
                    if (!aiVisible) {
                        window.PopupManager.onPopupHide();
                    }
                }
            }
        }
        
        function copyAIText() {
            const aiContent = aiCard && aiCard.querySelector('#aiCardContent');
            if (aiContent) {
                const text = aiContent.textContent || aiContent.innerText;
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(text).then(() => {
                        // Show brief feedback
                        if (aiCardCopy) {
                            const originalText = aiCardCopy.textContent;
                            aiCardCopy.textContent = 'Copied!';
                            setTimeout(() => {
                                aiCardCopy.textContent = originalText;
                            }, 1000);
                        }
                    }).catch(err => {
                        console.error('Failed to copy text:', err);
                    });
                }
            }
        }

        
        // Login/Logout functionality
        function updateLoginState() {
            if (isLoggedIn && currentUser) {
                userInfo.style.display = 'flex';
                loginPrompt.style.display = 'none';
                
                // Update user info display
                const userAvatar = userInfo.querySelector('.user-avatar');
                const userName = userInfo.querySelector('.user-name');
                const userStatus = userInfo.querySelector('.user-status');
                
                if (userAvatar && userName && userStatus) {
                    // Set avatar initials
                    const initials = currentUser.email ? currentUser.email.substring(0, 2).toUpperCase() : 'U';
                    userAvatar.textContent = initials;
                    
                    // Set user name (use email if no display name)
                    userName.textContent = currentUser.user_metadata?.full_name || currentUser.email || 'User';
                    
                    // Set plan status
                    const planType = userPlan?.plan_type || 'free';
                    let planDisplay;
                    if (planType === 'monthly_subscription') {
                        planDisplay = 'Unlimited Copilot';
                        updateInterviewsLeftDisplay(null); // Hide for pro plan
                    } else {
                        planDisplay = planType.charAt(0).toUpperCase() + planType.slice(1) + ' Plan';
                        updateInterviewsLeftDisplay(userPlan?.interviews_remaining);
                    }
                    userStatus.textContent = planDisplay;
                }
                logoutItem.style.display = 'block';
            } else {
                userInfo.style.display = 'none';
                loginPrompt.style.display = 'block';
                // Hide interviews left item if user is not logged in
                updateInterviewsLeftDisplay(null);
                logoutItem.style.display = 'none';
            }
        }
        
        loginBtn.addEventListener('click', () => {
            // Hide expanded menu when sign in is clicked
            const wasExpandedVisible = expandedMenu.classList.contains('show');
            expandedMenu.classList.remove('show');
            
            // Update popup manager for expanded menu close
            if (wasExpandedVisible && window.PopupManager) {
                window.PopupManager.onPopupHide();
            }
            expandBtn.classList.remove('active');
            showAuthContainer();
        });
        
        logoutItem.addEventListener('click', async () => {
            try {
                await window.auth.signOut();
                isLoggedIn = false;
                currentUser = null;
                userPlan = null;
                updateLoginState();
                const wasExpandedVisible = expandedMenu.classList.contains('show');
                expandedMenu.classList.remove('show');
                expandBtn.classList.remove('active');
                
                // Update popup manager for expanded menu close
                if (wasExpandedVisible && window.PopupManager) {
                    window.PopupManager.onPopupHide();
                }
            } catch (error) {
                console.error('Logout error:', error);
                
            } finally {
                updateInterviewsLeftDisplay(null); // Clear interviews display on logout
            }
        });
        





        // Menu item click handlers
        
        const interviewsLeftItem = document.getElementById('interviewsLeftItem'); // Get the interviews left item
        const interviewsLeftCount = document.getElementById('interviewsLeftCount'); // Get the span for the count

        // Function to update the display of interviews left
        function updateInterviewsLeftDisplay(count) {
            if (interviewsLeftItem && interviewsLeftCount) {
                if (typeof count === 'number' && count >= 0) {
                    interviewsLeftCount.textContent = count;
                    interviewsLeftItem.style.display = 'flex'; // Show the item
                } else {
                    interviewsLeftCount.textContent = '--';
                    interviewsLeftItem.style.display = 'none'; // Hide the item if no valid count
                }
            }
        }

        // Add click handler for interviews left item to open interm.ai
        if (interviewsLeftItem) {
            interviewsLeftItem.addEventListener('click', () => {
                if (window.electron && window.electron.openExternal) {
                    window.electron.openExternal('https://interm.ai');
                } else {
                    window.open('https://interm.ai', '_blank');
                }
            });
            // Add cursor pointer style
            interviewsLeftItem.style.cursor = 'pointer';
        }

        // Add click handler for user profile to open interm.ai
        if (userInfo) {
            userInfo.addEventListener('click', () => {
                if (window.electron && window.electron.openExternal) {
                    window.electron.openExternal('https://interm.ai');
                } else {
                    window.open('https://interm.ai', '_blank');
                }
            });
            // Add cursor pointer style
            userInfo.style.cursor = 'pointer';
        }

        
        // ── Help-Center modal wiring ──────────────────────────
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize content observer for dynamic resizing
            setupContentObserver();
            
            const helpModal       = document.getElementById('helpCenterModal');
            const closeHelpModal  = document.getElementById('closeHelpModal');
            const helpMenuItem    = document.getElementById('helpItem');

            function showHelpModal() {
                helpModal.style.display = 'flex';
                // Allow click-outside to close
                helpModal.addEventListener('click', e => {
                    if (e.target === helpModal) hideHelpModal();
                });
                if (window.PopupManager) window.PopupManager.onPopupShow();
            }
            function hideHelpModal() {
                helpModal.style.display = 'none';
                if (window.PopupManager) window.PopupManager.onPopupHide();
            }

            helpMenuItem.addEventListener('click', showHelpModal);
            closeHelpModal.addEventListener('click', hideHelpModal);
        });
        

        
        document.getElementById('minimizeItem').addEventListener('click', () => {
             window.electron.minimize();
         });
        
        document.getElementById('quitItem').addEventListener('click', () => {
             window.electron.quit();
         });
        
        // Check for existing session on startup
        async function checkExistingSession() {
            try {
                console.log('[UI] Checking for existing session...');
                const session = await window.auth.getSession();
                
                if (session) {
                    console.log('[UI] Valid session found, updating UI state');
                    isLoggedIn = true;
                    
                    // Get user info from the auth service
                    try {
                        const userInfo = await window.auth.getUserInfo();
                        if (userInfo && userInfo.user) {
                            currentUser = userInfo.user;
                            userPlan = userInfo.plan;
                            console.log('[UI] User info loaded:', currentUser.email, 'Plan:', userPlan?.plan_type, 'Interviews Left:', userPlan?.interviews_remaining);
                        }
                    } catch (userInfoError) {
                        console.warn('[UI] Could not load user info:', userInfoError);
                    }
                } else {
                    console.log('[UI] No valid session found');
                    isLoggedIn = false;
                    currentUser = null;
                    userPlan = null;
                }
                
                updateLoginState();
            } catch (error) {
                console.error('[UI] Error checking session:', error);
                isLoggedIn = false;
                currentUser = null;
                userPlan = null;
                updateLoginState();
            }
        }
        
        // Initialize login state
        checkExistingSession();

        // Authentication functionality
        const authContainer = document.getElementById('authContainer');
        const authForm = document.getElementById('authForm');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const authStatus = document.getElementById('authStatus');
        const closeAuth = document.getElementById('closeAuth');

        // Show auth container function
        function showAuthContainer() {
            if (authContainer) {
                // Force display and visibility
                authContainer.style.display = 'block';
                authContainer.style.visibility = 'visible';
                authContainer.style.opacity = '1';
                authContainer.classList.add('show');
                
                // Focus on email input
                if (emailInput) {
                    setTimeout(() => emailInput.focus(), 100);
                }
                
                // Update popup manager
                if (window.PopupManager) {
                    window.PopupManager.onPopupShow();
                }
            }
        }

        // Hide auth container function
        function hideAuthContainer() {
            authContainer.classList.remove('show');
            // Reset inline styles to let CSS take over
            authContainer.style.display = '';
            authContainer.style.visibility = '';
            authContainer.style.opacity = '';
            authForm.reset();
            authStatus.className = 'auth-status';
            authStatus.textContent = '';
            if (window.PopupManager) {
                window.PopupManager.onPopupHide();
            }
        }

        // Show auth status
        function showAuthStatus(message, isError = false) {
            authStatus.textContent = message;
            authStatus.className = `auth-status ${isError ? 'auth-error' : 'auth-success'}`;
        }

        // Close auth container
        closeAuth.addEventListener('click', hideAuthContainer);

        // Handle form submission
        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            
            if (!email || !password) {
                showAuthStatus('Please enter both email and password', true);
                return;
            }
            
            const loginButton = authForm.querySelector('.login-button');
            loginButton.disabled = true;
            loginButton.textContent = 'Signing in...';
            
            try {
                // Use the auth API from preload.js
                const result = await window.auth.signInWithEmail(email, password);
                
                if (!result.success) {
                     showAuthStatus(result.error || 'Sign in failed', true);
                 } else {
                     showAuthStatus('Sign in successful!', false);
                     
                     // Set logged in state and update UI
                     isLoggedIn = true;
                     
                     // Get updated user info
                     try {
                         const userInfo = await window.auth.getUserInfo();
                         if (userInfo && userInfo.user) {
                             currentUser = userInfo.user;
                             userPlan = userInfo.plan;
                         }
                     } catch (userInfoError) {
                         console.warn('[UI] Could not load user info after login:', userInfoError);
                     }
                     
                     // Update login state and hide auth container after a short delay
                     setTimeout(() => {
                         updateLoginState();
                         hideAuthContainer();
                     }, 1000);
                 }
            } catch (error) {
                console.error('Sign in error:', error);
                showAuthStatus('An error occurred during sign in', true);
            } finally {
                loginButton.disabled = false;
                loginButton.textContent = 'Sign In';
            }
        });



        // Google sign-in handler moved to DOMContentLoaded section after renderer-auth.js loads

        function resetGoogleButton() {
            const googleLoginBtn = document.getElementById('googleLoginBtn');
            if (googleLoginBtn) {
                googleLoginBtn.disabled = false;
                googleLoginBtn.innerHTML = '<img src="https://img.icons8.com/color/16/000000/google-logo.png" alt="Google logo"/> Sign in with Google';
            }
        }

        // Handle auth callback from deep link - use renderer auth
        function setupAuthCallbackHandler() {
            window.electron.on('auth:callback-url', async (callbackUrl) => {
                console.log('[UI] Received auth callback:', callbackUrl);
                
                try {
                    // Use renderer auth to handle the callback
                    const result = await window.auth.handleAuthCallback(callbackUrl);
                    
                    if (result.session) {
                        console.log('[UI] Google auth successful:', result.session.user.email);
                        showAuthStatus('Google sign-in successful!');
                        
                        // Update login state and hide auth container after a short delay
                        setTimeout(() => {
                            updateLoginState();
                            hideAuthContainer();
                        }, 1500);
                    } else {
                        console.error('[UI] Google auth failed:', result.error);
                        showAuthStatus('Google sign-in failed: ' + result.error.message, true);
                        resetGoogleButton();
                    }
                } catch (error) {
                    console.error('[UI] Error handling auth callback:', error);
                    showAuthStatus('Google sign-in failed: ' + error.message, true);
                    resetGoogleButton();
                }
            });
        }

        // Set up the callback handler
        setupAuthCallbackHandler();

        // Set up auth success listener for Google OAuth
        window.auth.onAuthSuccess(async (sessionData) => {
            console.log('[UI] Auth success event received:', sessionData);
            showAuthStatus('Google sign-in successful!');
            
            try {
                // Set logged in state
                isLoggedIn = true;
                
                // Extract user info from session data
                if (sessionData && sessionData.user) {
                    currentUser = sessionData.user;
                    console.log('[UI] Google user info loaded:', currentUser.email);
                    
                    // Try to get additional user info (plan details) if getUserInfo is available
                    if (window.auth.getUserInfo) {
                        try {
                            const userInfo = await window.auth.getUserInfo();
                            if (userInfo && userInfo.user) {
                                currentUser = userInfo.user;
                                userPlan = userInfo.plan;
                                console.log('[UI] Extended user info loaded:', currentUser.email, 'Plan:', userPlan?.plan_type);
                            }
                        } catch (userInfoError) {
                            console.warn('[UI] Could not load extended user info:', userInfoError);
                        }
                    }
                } else {
                    console.warn('[UI] No user data in session');
                }
                
                // Update the UI immediately
                updateLoginState();
                
                // Hide auth container after a short delay
                setTimeout(() => {
                    hideAuthContainer();
                    resetGoogleButton();
                }, 1500);
                
            } catch (error) {
                console.error('[UI] Error processing auth success:', error);
                showAuthStatus('Authentication succeeded but failed to update UI', true);
                resetGoogleButton();
            }
        });

        // Set up auth error listener
        window.auth.onAuthError((errorData) => {
            console.error('[UI] Auth error event received:', errorData);
            showAuthStatus('Authentication failed: ' + errorData.message, true);
            resetGoogleButton();
        });

        // Close auth container when clicking outside
        authContainer.addEventListener('click', (e) => {
            if (e.target === authContainer) {
                hideAuthContainer();
            }
        });

        // Keyboard shortcut to show auth removed - conflicts with start listening hotkey

        // Expose showAuthContainer globally for potential use
        window.showAuthContainer = showAuthContainer;

        
        // Suggestion button functionality
        document.querySelectorAll('.suggestion-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                if (btn.textContent === 'Use Suggestion') {
                    btn.textContent = 'Applied ✓';
                    btn.style.background = 'var(--secondary)'; /* Or a specific success color if defined */
                    setTimeout(() => {
                        btn.closest('.ai-suggestion').style.opacity = '0.5';
                    }, 500);
                } else if (btn.textContent === 'Dismiss') {
                    btn.closest('.ai-suggestion').style.display = 'none';
                }
            });
        });

        // Close popups when clicking outside
        document.addEventListener('click', (e) => {
            
            // Close expanded menu if clicking outside
            if (!expandedMenu.contains(e.target) && !expandBtn.contains(e.target)) {
                const wasExpandedVisible = expandedMenu.classList.contains('show');
                expandedMenu.classList.remove('show');
                expandBtn.classList.remove('active');
                
                // Update popup manager for expanded menu close
                if (wasExpandedVisible && window.PopupManager) {
                    window.PopupManager.onPopupHide();
                }
            }

            // Close preferences panel if clicking outside

        });

        // Simulate AI suggestions appearing
        setTimeout(() => {
            if (Math.random() > 0.5) {
                aiBtn.style.animation = 'pulse 1s ease-in-out 3';
            }
        }, 5000);

        // Transcript integration - Connect with backend transcript data
        let transcriptContent;
        let unifiedTranscriptContent;
        let currentInterimElement = null;

        document.addEventListener('DOMContentLoaded', function() {
            transcriptContent = document.getElementById('transcriptContent');
            unifiedTranscriptContent = document.getElementById('transcriptCardContent');
        });
        
        // Function to format timestamp
        function formatTimestamp() {
            const now = new Date();
            return now.toLocaleTimeString('en-US', { 
                hour12: true, 
                hour: 'numeric', 
                minute: '2-digit' 
            });
        }
        
        // Function to add transcript message
        function addTranscriptMessage(text, speaker = 'You', isInterim = false, hideSpeaker = false) {
            const placeholder = document.getElementById('transcript-placeholder');
            if (placeholder) {
                placeholder.remove();
            }
            if (!text || text.trim() === '') return;

            const speakerHtml = hideSpeaker ? '' : `<span class="speaker-label">${speaker}</span>`;
            
            if (isInterim) {
                // Handle interim transcript (real-time updates)
                if (currentInterimElement) {
                    // Update existing interim message
                    const messageText = currentInterimElement.querySelector('.message-text');
                    if (messageText) {
                        messageText.textContent = text;
                    }
                    
                    // Also update in unified transcript card
                    if (unifiedTranscriptContent) {
                        const unifiedInterimElements = unifiedTranscriptContent.querySelectorAll('.transcript-message.interim');
                        const lastUnifiedInterim = unifiedInterimElements[unifiedInterimElements.length - 1];
                        if (lastUnifiedInterim) {
                            const unifiedMessageText = lastUnifiedInterim.querySelector('.message-text');
                            if (unifiedMessageText) {
                                unifiedMessageText.textContent = text;
                            }
                        }
                    }
                } else {
                    // Create new interim message
                    const messageDiv = document.createElement('div');
                    const speakerClass = speaker ? (speaker.toLowerCase() === 'you' ? 'you' : 'interviewer') : 'interviewer';
                    messageDiv.className = `transcript-message ${speakerClass} interim`;
                    messageDiv.innerHTML = `
                        <div class="message-header">
                            ${speakerHtml}
                            <span class="message-time">${formatTimestamp()}</span>
                        </div>
                        <div class="message-text">${text}</div>
                    `;
                    
                    // Add interim styling
                    messageDiv.style.opacity = '0.7';
                    messageDiv.style.fontStyle = 'italic';
                    
                    if (transcriptContent) {
                        transcriptContent.appendChild(messageDiv);
                    }
                    
                    // Hide placeholder when first message appears
                    hidePlaceholderMessages();
                    
                    // Also add to unified transcript card
                    if (unifiedTranscriptContent) {
                        const unifiedMessageDiv = messageDiv.cloneNode(true);
                        unifiedTranscriptContent.appendChild(unifiedMessageDiv);
                        unifiedTranscriptContent.scrollTop = unifiedTranscriptContent.scrollHeight;
                    }
                    
                    currentInterimElement = messageDiv;
                    
                    // Auto-scroll to bottom
                    if (transcriptContent) {
                        transcriptContent.scrollTop = transcriptContent.scrollHeight;
                    }
                }
            } else {
                // Handle final transcript
                if (currentInterimElement) {
                    // Convert interim to final
                    currentInterimElement.classList.remove('interim');
                    currentInterimElement.style.opacity = '1';
                    currentInterimElement.style.fontStyle = 'normal';
                    
                    const messageText = currentInterimElement.querySelector('.message-text');
                    if (messageText) {
                        messageText.textContent = text;
                    }
                    
                    // Also update in unified transcript card
                    if (unifiedTranscriptContent) {
                        const unifiedInterimElements = unifiedTranscriptContent.querySelectorAll('.transcript-message.interim');
                        const lastUnifiedInterim = unifiedInterimElements[unifiedInterimElements.length - 1];
                        if (lastUnifiedInterim) {
                            lastUnifiedInterim.classList.remove('interim');
                            lastUnifiedInterim.style.opacity = '1';
                            lastUnifiedInterim.style.fontStyle = 'normal';
                            const unifiedMessageText = lastUnifiedInterim.querySelector('.message-text');
                            if (unifiedMessageText) {
                                unifiedMessageText.textContent = text;
                            }
                        }
                    }
                    
                    currentInterimElement = null;
                } else {
                    // Create new final message
                    const messageDiv = document.createElement('div');
                    const speakerClass = speaker ? (speaker.toLowerCase() === 'you' ? 'you' : 'interviewer') : 'interviewer';
                    messageDiv.className = `transcript-message ${speakerClass}`;
                    messageDiv.innerHTML = `
                        <div class="message-header">
                            ${speakerHtml}
                            <span class="message-time">${formatTimestamp()}</span>
                        </div>
                        <div class="message-text">${text}</div>
                    `;                    
                    
                    if (transcriptContent) {
                        transcriptContent.appendChild(messageDiv);
                    }
                    
                    // Hide placeholder when first message appears
                    hidePlaceholderMessages();
                    
                    // Also add to unified transcript card
                    if (unifiedTranscriptContent) {
                        const unifiedMessageDiv = messageDiv.cloneNode(true);
                        unifiedTranscriptContent.appendChild(unifiedMessageDiv);
                        unifiedTranscriptContent.scrollTop = unifiedTranscriptContent.scrollHeight;
                    }
                    
                    // Auto-scroll to bottom
                    if (transcriptContent) {
                        transcriptContent.scrollTop = transcriptContent.scrollHeight;
                    }
                }
                
                // Trigger window resize after transcript update
                debouncedWindowResize();
            }
        }
        
        // Function to hide placeholder messages when transcript content appears
        function hidePlaceholderMessages() {
            // Hide placeholder in transcript card
            const transcriptPlaceholder = document.querySelector('#transcriptCardContent .placeholder-message');
            if (transcriptPlaceholder) {
                transcriptPlaceholder.style.display = 'none';
            }
            
            // Hide placeholder in unified transcript
            const unifiedPlaceholder = document.querySelector('#transcriptContent .placeholder-message');
            if (unifiedPlaceholder) {
                unifiedPlaceholder.style.display = 'none';
            }
        }
        
        // Function to clear existing demo content
        function clearDemoContent() {
            // Remove demo messages but keep the structure
            const demoMessages = transcriptContent.querySelectorAll('.transcript-message');
            demoMessages.forEach(msg => {
                if (!msg.classList.contains('interim')) {
                    msg.remove();
                }
            });
        }
        
        // Listen for transcript events from backend
        if (window.electron && window.electron.onTranscript) {
            window.electron.onTranscript((data) => {
                console.log('🎯 [FRONTEND] Received transcript event:', data);              
                // Remove placeholder if it exists
                const placeholder = document.getElementById('transcript-placeholder');
                if (placeholder) {
                    placeholder.parentElement.remove();
                }
                
                // Determine speaker based on available data
                let speaker = 'Interviewer'; // Default
                
                let hideSpeaker = false;
                // For SOX (macOS < 15): Use speaker diarization if available
                if (data.speakerInfo && data.speakerInfo.hasSpeakerInfo && data.speakerInfo.segments && data.speakerInfo.segments.length > 0) {
                    // Use the role from the first segment (speaker diarization)
                    const firstSegment = data.speakerInfo.segments[0];
                    if (firstSegment.role === 'me' || firstSegment.role === 'INTERVIEWEE') {
                        speaker = 'You';
                    } else if (firstSegment.role === 'interviewer' || firstSegment.role === 'INTERVIEWER') {
                        speaker = 'Interviewer';
                    }
                } else {
                    // For macOS 15+: Use source-based detection
                    speaker = data.source === 'microphone' ? 'You' : 'Interviewer';
                    hideSpeaker = true;
                }
                addTranscriptMessage(data.text || data.transcript, speaker, false, hideSpeaker);
            });
        }
        
        // Listen for interim transcript events from backend
        if (window.electron && window.electron.onInterimTranscript) {
            window.electron.onInterimTranscript((data) => {
                console.log('🎯 [FRONTEND] Received interim transcript event:', data);
                
                // Remove placeholder if it exists
                const placeholder = document.getElementById('transcript-placeholder');
                if (placeholder) {
                    placeholder.parentElement.remove();
                }
                
                // Determine speaker based on available data
                let speaker = 'Interviewer'; // Default
                
                // For SOX (macOS < 15): Use speaker diarization if available
                if (data.speakerInfo && data.speakerInfo.hasSpeakerInfo && data.speakerInfo.segments && data.speakerInfo.segments.length > 0) {
                    // Use the role from the first segment (speaker diarization)
                    const firstSegment = data.speakerInfo.segments[0];
                    if (firstSegment.role === 'me' || firstSegment.role === 'INTERVIEWEE') {
                        speaker = 'You';
                    } else if (firstSegment.role === 'interviewer' || firstSegment.role === 'INTERVIEWER') {
                        speaker = 'Interviewer';
                    }
                } else {
                    // For macOS 15+: Use source-based detection
                    speaker = data.source === 'microphone' ? 'You' : 'Interviewer';
                }
                addTranscriptMessage(data.text || data.transcript, speaker, true);
            });
        }
        
        // Listen for recording status to manage transcript state
        if (window.electron && window.electron.onRecordingStatus) {
            window.electron.onRecordingStatus((data) => {
                if (data.isRecording) {
                    console.log('Recording started - transcript ready');
                    // Switch from loading to active state
                    recordBtn.classList.remove('loading');
                    recordBtn.classList.add('active');
                    // Optionally clear previous session transcript
                    // clearDemoContent();
                } else {
                    console.log('Recording stopped');
                    // Finalize any interim transcript
                    if (currentInterimElement) {
                        currentInterimElement.classList.remove('interim');
                        currentInterimElement.style.opacity = '1';
                        currentInterimElement.style.fontStyle = 'normal';
                        currentInterimElement = null;
                    }
                }
            });
        }
        
        // Function to process markdown and apply syntax highlighting
        function processMarkdownContent(text) {
            // Convert markdown to HTML with proper code block handling
            let processedText = text;
            
            // Process code blocks with language detection
            processedText = processedText.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                const language = lang || 'text';
                const escapedCode = code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return `<pre><code class="language-${language}">${escapedCode}</code></pre>`;
            });
            
            // Process inline code
            processedText = processedText.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Process headers
            processedText = processedText.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, title) => {
                const level = hashes.length;
                return `<h${level}>${title}</h${level}>`;
            });
            
            // Process bold text
            processedText = processedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Process italic text
            processedText = processedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Process lists
            processedText = processedText.replace(/^[-*+]\s+(.+)$/gm, '<li>$1</li>');
            processedText = processedText.replace(/((<li>.*<\/li>\n?)+)/g, '<ul>$1</ul>');
            
            // Process numbered lists
            processedText = processedText.replace(/^\d+\.\s+(.+)$/gm, '<li>$1</li>');
            
            // Process line breaks, but not inside <pre> blocks
            processedText = processedText.replace(
                /(<pre[\s\S]*?<\/pre>)|(\n)/g,
                (match, preBlock, newline) => {
                    return preBlock || '<br>';
                }
            );
            
            return processedText;
        }

        // Function to add or update the AI suggestion card
        let currentStreamingCard = null;
        let isStreaming = false;

        function addSuggestionMessage(text, isFinal = true, source = null) {
            const aiCardContent = document.getElementById('aiCardContent');
            if (!aiCardContent) {
                console.error('[UI] AI card content area not found.');
                return;
            }

            // Create source label if provided
            const sourceLabel = source === 'voice' ? '<span class="source-label voice-label">🎤 Voice Question</span>' : 
                               source === 'screenshot' ? '<span class="source-label screenshot-label">📸 Screenshot</span>' : '';

            if (!isStreaming || !currentStreamingCard) {
                // Start new streaming session - clear previous content
                aiCardContent.innerHTML = '';
                isStreaming = true;
                
                // Create new answer card for streaming
                currentStreamingCard = document.createElement('div');
                currentStreamingCard.className = 'answer-card';
                currentStreamingCard.innerHTML = `
                    <div class="answer-header">
                        ${sourceLabel}
                    </div>
                    <div class="answer-text"></div>
                    <div class="answer-actions" style="display: none;">
                        <button class="copy-btn" onclick="copyAnswer(this)">
                            <svg width="14" height="14" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z" fill="currentColor"/></svg>
                            Copy
                        </button>
                    </div>
                `;
                aiCardContent.appendChild(currentStreamingCard);
            }

            // Update the text content progressively
            const answerTextElement = currentStreamingCard.querySelector('.answer-text');
            if (answerTextElement) {
                // Process the text for markdown and code highlighting
                const processedText = processMarkdownContent(text);
                answerTextElement.innerHTML = processedText;
                
                // Apply syntax highlighting to code blocks
                if (window.Prism) {
                    Prism.highlightAllUnder(answerTextElement);
                }

                // Render math equations
                if (window.MathJax) {
                    MathJax.typesetPromise([answerTextElement]).catch((err) => {
                        console.warn('MathJax rendering error:', err);
                    });
                }
            }

            if (isFinal) {
                // Show copy button when streaming is complete
                const actionsElement = currentStreamingCard.querySelector('.answer-actions');
                if (actionsElement) {
                    actionsElement.style.display = 'block';
                }
                isStreaming = false;
                currentStreamingCard = null;
            }

            // Ensure the unified AI card is visible
            if (!aiCard.classList.contains('show')) {
                toggleAICard();
            }
            
            // Trigger window resize after content update
            debouncedWindowResize();
        }

        // Listen for AI suggestion responses
        if (window.electron && window.electron.onSuggestion) {
            window.electron.onSuggestion((data) => {
                console.log('[UI] Received AI suggestion:', data);
                const suggestionText = data.text || 'No suggestion available.';
                addSuggestionMessage(suggestionText, data.isFinal, data.source);
            });
        }

        // Listen for streaming AI suggestion chunks
        if (window.electron && window.electron.onSuggestionChunk) {
            window.electron.onSuggestionChunk((data) => {
                console.log('[UI] Received AI suggestion chunk:', data);
                const suggestionText = data.fullText || '';
                addSuggestionMessage(suggestionText, data.isFinal, data.source);
            });
        }

        // Listen for streaming AI suggestion partial results
        if (window.electron && window.electron.onSuggestionPartial) {
            window.electron.onSuggestionPartial((data) => {
                console.log('[UI] Received AI suggestion partial:', data);
                const suggestionText = data.fullText || '';
                addSuggestionMessage(suggestionText, data.isFinal, data.source);
            });
        }

        // Listen for suggestion processing events (progress indicator)
        if (window.electron && window.electron.onSuggestionProcessing) {
            window.electron.onSuggestionProcessing((data) => {
                console.log('[UI] AI suggestion processing started:', data);
                
                // Show progress indicator in AI card
                const aiCardContent = document.getElementById('aiCardContent');
                if (aiCardContent) {
                    aiCardContent.innerHTML = `
                        <div class="answer-card">
                            <div class="answer-header">
                                <svg class="loading-spinner" width="16" height="16" viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="31.416" stroke-dashoffset="31.416">
                                        <animate attributeName="stroke-dasharray" dur="2s" values="0 31.416;15.708 15.708;0 31.416" repeatCount="indefinite"/>
                                        <animate attributeName="stroke-dashoffset" dur="2s" values="0;-15.708;-31.416" repeatCount="indefinite"/>
                                    </circle>
                                </svg>
                                Processing Screenshot...
                            </div>
                            <div class="answer-text">Analyzing screenshot and generating AI suggestions...</div>
                        </div>
                    `;
                }
                
                // Ensure the AI card is visible
                const aiCard = document.getElementById('aiCard');
                if (aiCard && !aiCard.classList.contains('show')) {
                    toggleAICard();
                }
            });
        }

        
        // Listen for error events from backend
        if (window.electron && window.electron.onError) {
            window.electron.onError((data) => {
                console.log('[UI] Error received:', data);
                
                // Reset button state if recording was attempted but failed
                if (isRecording && (data.type === 'plan-limit' || data.message?.includes('User ID is required'))) {
                    isRecording = false;
                    recordBtn.classList.remove('active', 'loading');
                    
                    // Re-enable screenshot button when recording fails
                    const screenshotBtn = document.getElementById('screenshotBtn');
                    if (screenshotBtn) {
                        screenshotBtn.disabled = false;
                        screenshotBtn.style.opacity = '1';
                        screenshotBtn.style.cursor = 'pointer';
                    }
                    
                    // Reset button text to original state
                    const listenText = recordBtn.querySelector('.listen-text');
                    const hotkeyHint = recordBtn.querySelector('.hotkey-hint').outerHTML;
                    listenText.innerHTML = `Start Listen ${hotkeyHint}`;
                }
                
                const statusBar = document.getElementById('statusBar');
                if (statusBar) {
                    let errorMessage = '';
                    if (data.message && data.message.includes('User ID is required')) {
                        errorMessage = 'Authentication Required: Please log in to start recording.';
                    } else if (data.type === 'plan-limit') {
                        errorMessage = 'Plan limit reached. Please upgrade your plan.';
                    } else {
                        errorMessage = data.message || 'An error occurred.';
                    }
                    statusBar.textContent = errorMessage;
                    statusBar.classList.add('show');
                    setTimeout(() => {
                        statusBar.classList.remove('show');
                    }, 8000);
                }
            });
        }
        
        // Plan limit reached events are now handled via the error event above
    </script>

    <!-- Popup Manager Script -->
    <script src="popup-manager.js"></script>




    <!-- Help Center Modal -->
    <div id="helpCenterModal" class="plan-limit-modal" style="display: none;">
        <div class="plan-limit-modal-content">
            <div class="plan-limit-modal-header">
                <h3>Help Center</h3>
                <button class="close-plan-modal" id="closeHelpModal">&times;</button>
            </div>
            <div class="plan-limit-modal-message">
                <h4 style="margin-top: 0; color: #333; font-size: 16px;">Audio Recording</h4>
                <p>For the best transcript quality and AI suggestions, we recommend using earphones. Earphone support is now available for all macOS versions.</p>
                
                <h4 style="margin-top: 20px; color: #333; font-size: 16px;">Screenshot Feature</h4>
                <p>Take a screenshot and get AI-powered analysis and suggestions:</p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li><strong>Cmd+Shift+Enter</strong> (macOS) or <strong>Ctrl+Shift+Enter</strong> (Windows) - Capture screenshot and analyze with AI</li>
                    <li>The AI will identify issues, errors, or problems in your screenshot and provide solutions</li>
                    <li>Perfect for debugging code, analyzing error messages, or getting help with UI issues</li>
                </ul>
                
                <p style="margin-top: 20px;">Still have questions? Email us at 
                   <a href="mailto:founders@interm.ai" style="color: #66b3ff; text-decoration: none;">founders@interm.ai</a></p>
            </div>
        </div>
    </div>
    </div> <!-- End of root container -->
    <!-- Microphone capture for older macOS versions -->
    <script src="microphone-capture.js"></script>
    
    <!-- Windows audio capture for Windows platform -->
    <script src="windows-audio-capture.js"></script>
    
    <script>
        // Handle microphone capture events from main process
        if (window.electron) {
            // Listen for server messages forwarded by main process
            window.electron.startMicrophoneCapture(() => {
                document.dispatchEvent(new CustomEvent('start-microphone-capture'));
            });
            
            window.electron.stopMicrophoneCapture(() => {
                document.dispatchEvent(new CustomEvent('stop-microphone-capture'));
            });
            
            // Handle Windows audio capture events from main process
            window.electron.onStartWindowsAudioCapture(() => {
                console.log('[RENDERER] start-windows-audio-capture received');
                document.dispatchEvent(new CustomEvent('start-windows-audio-capture'));
            });
            
            window.electron.onStopWindowsAudioCapture(() => {
                document.dispatchEvent(new CustomEvent('stop-windows-audio-capture'));
            });
        }
    </script>

    <!-- Permission Notification Handler -->
    <script>
        // Permission notification will use the main toast implementation
        let currentPermissionType = null;
        
        // Permission messages will come from backend
        
        // Show permission toast
        function showPermissionToast(errorData) {
            currentPermissionType = errorData.permissionType;
            
            if (errorData.message) {
                // Use the message from backend
                toastMessage.textContent = errorData.message;
                
                // Set the deep link URL if provided
                if (errorData.url) {
                    toastAction.dataset.url = errorData.url;   // stash the deep-link
                    toastAction.style.display = 'inline-block';
                } else {
                    toastAction.style.display = 'none';
                }
                
                toast.classList.add('show');
                
                // Update window size to accommodate toast
                updateWindowSize();
                
                // No auto-hide - user must manually close
            }
        }
        
        // Hide permission toast
        function hidePermissionToast() {
            toast.classList.remove('show');
            
            // Update window size after hiding toast
            updateWindowSize();
        }
        
        // Toast close button is already handled in the earlier implementation
        
        // Listen for permission error events from main process
        if (window.electron) {
            window.electron.onPermError((errorData) => {
                console.log('Permission error received:', errorData);
                if (errorData.isPersistent) {
                    showPermissionToast(errorData);
                }
            });
            
            // Microphone access check is now handled in preload.js
            
            // Listen for microphone status updates
            window.electron.onMicStatus && window.electron.onMicStatus((data) => {
                console.log('[RENDERER] Microphone status update:', data);
                
                if (!data.granted && data.error) {
                    // Show user-friendly error message
                    let errorMessage = 'Microphone access denied';
                    
                    if (data.error.name === 'NotAllowedError') {
                        if (navigator.platform.includes('Win')) {
                            errorMessage = 'Microphone access is disabled in Windows settings. Please enable microphone access in Windows Privacy Settings.';
                        } else {
                            errorMessage = 'Microphone access denied. Please allow microphone access in your browser or system settings.';
                        }
                    } else if (data.error.name === 'NotFoundError') {
                        errorMessage = 'No microphone device found. Please connect a microphone and try again.';
                    }
                    
                    // Show error toast (reuse existing toast mechanism)
                    const statusBar = document.getElementById('statusBar');
                    if (statusBar) {
                        statusBar.textContent = errorMessage;
                        statusBar.classList.add('show');
                        setTimeout(() => {
                            statusBar.classList.remove('show');
                        }, 8000);
                    }
                }
            });
        }
        
        // Optional: Add manual permission check functions for testing
        window.checkMicrophonePermission = async () => {
            if (window.electron) {
                const hasPermission = await window.electron.invoke('check-microphone-permission');
                console.log('Microphone permission:', hasPermission);
                return hasPermission;
            }
        };
        
        window.checkScreenPermission = async () => {
            if (window.electron) {
                const hasPermission = await window.electron.invoke('check-screen-permission');
                console.log('Screen permission:', hasPermission);
                return hasPermission;
            }
        };
    </script>

    <script src="./renderer-auth.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const authForm = document.getElementById('authForm');
            if(authForm) {
                authForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const email = document.getElementById('emailInput').value;
                    const password = document.getElementById('passwordInput').value;
                    const { error } = await window.auth.signInWithEmailPassword(email, password);
                    if (error) {
                        console.error('Sign-in failed:', error.message);
                        // Optionally, display the error to the user
                    }
                });
            }

            const googleLoginBtn = document.getElementById('googleLoginBtn');
            if(googleLoginBtn) {
                googleLoginBtn.addEventListener('click', async () => {
                    try {
                        googleLoginBtn.disabled = true;
                        googleLoginBtn.textContent = 'Opening browser...';
                        
                        // Clear any previous auth status
                        showAuthStatus('');
                        
                        const result = await window.auth.signInWithGoogle();
                        
                        if (result.success) {
                            showAuthStatus('Check your browser to complete sign-in');
                            // The callback will be handled by the auth success listener
                        } else {
                            showAuthStatus('Failed to start Google sign-in: ' + result.error, true);
                            resetGoogleButton();
                        }
                    } catch (error) {
                        console.error('[UI] Google sign-in error:', error);
                        showAuthStatus('An error occurred during Google sign-in', true);
                        resetGoogleButton();
                    }
                });
            }

            function resetGoogleButton() {
                googleLoginBtn.disabled = false;
                googleLoginBtn.innerHTML = `
                    <svg width="18" height="18" viewBox="0 0 24 24" style="margin-right: 8px;">
                        <path fill="#4285f4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                        <path fill="#34a853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                        <path fill="#fbbc05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                        <path fill="#ea4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                    </svg>
                    Continue with Google
                `;
            }

            window.electron.on('auth:callback-url', (url) => {
                window.auth.handleAuthCallback(url);
            });
        });
    </script>
</body>
</html>